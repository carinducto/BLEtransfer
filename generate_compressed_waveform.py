#!/usr/bin/env python3
"""
Generate a pre-compressed waveform for benchmark testing.
This creates a static C array that can be embedded in the PSoC firmware.
"""

import struct
import zlib
import math

# Waveform parameters (matching app_waveform.c)
SAMPLE_RATE_HZ = 50_000_000
SAMPLES_PER_BLOCK = 2376
CARRIER_FREQ_HZ = 5_000_000
PI = math.pi

# Echo parameters
BASELINE_NOISE_AMPLITUDE = 100
FIRST_ECHO_AMPLITUDE = 2_500_000
SECOND_ECHO_AMPLITUDE = 5_000_000
THIRD_ECHO_AMPLITUDE = 1_600_000

TRIGGER_TIME_SAMPLES = 250
FIRST_ECHO_TIME_SAMPLES = 375
SECOND_ECHO_TIME_SAMPLES = 875
THIRD_ECHO_TIME_SAMPLES = 1250

ECHO_DURATION_SAMPLES = 100
ECHO_DECAY_RATE = 0.03

def generate_baseline_noise(sample_index, seed=12345):
    """Simple PRNG for noise"""
    # Linear congruential generator
    seed = ((seed * 1103515245) + 12345) & 0x7FFFFFFF
    noise = (seed % (BASELINE_NOISE_AMPLITUDE * 2)) - BASELINE_NOISE_AMPLITUDE
    return noise, seed

def generate_echo(sample_index, echo_center, amplitude, decay_rate):
    """Generate echo with carrier and exponential decay"""
    relative_time = sample_index - echo_center
    envelope = math.exp(-decay_rate * abs(relative_time))
    carrier_phase = 2.0 * PI * CARRIER_FREQ_HZ * sample_index / SAMPLE_RATE_HZ
    carrier = math.sin(carrier_phase)
    echo = int(amplitude * envelope * carrier)
    return echo

def generate_waveform():
    """Generate a complete waveform matching PSoC generation"""
    samples = []
    seed = 12345

    for i in range(SAMPLES_PER_BLOCK):
        sample = 0

        # Add baseline noise
        noise, seed = generate_baseline_noise(i, seed)
        sample += noise

        # First echo
        if FIRST_ECHO_TIME_SAMPLES <= i < FIRST_ECHO_TIME_SAMPLES + ECHO_DURATION_SAMPLES * 3:
            sample += generate_echo(i, FIRST_ECHO_TIME_SAMPLES, FIRST_ECHO_AMPLITUDE, ECHO_DECAY_RATE)

        # Second echo
        if SECOND_ECHO_TIME_SAMPLES <= i < SECOND_ECHO_TIME_SAMPLES + ECHO_DURATION_SAMPLES * 3:
            sample += generate_echo(i, SECOND_ECHO_TIME_SAMPLES, SECOND_ECHO_AMPLITUDE, ECHO_DECAY_RATE)

        # Third echo
        if THIRD_ECHO_TIME_SAMPLES <= i < THIRD_ECHO_TIME_SAMPLES + ECHO_DURATION_SAMPLES * 3:
            sample += generate_echo(i, THIRD_ECHO_TIME_SAMPLES, THIRD_ECHO_AMPLITUDE, ECHO_DECAY_RATE * 1.5)

        # Clamp to 24-bit signed range
        sample = max(-8388608, min(8388607, sample))
        samples.append(sample)

    return samples

def pack_24bit_samples(samples):
    """Pack samples into 24-bit little-endian bytes"""
    data = bytearray()
    for sample in samples:
        # Pack as 24-bit little-endian
        data.append(sample & 0xFF)
        data.append((sample >> 8) & 0xFF)
        data.append((sample >> 16) & 0xFF)
    return bytes(data)

def delta_encode(samples):
    """Delta encode samples to 16-bit deltas"""
    deltas = bytearray()
    prev = 0
    for sample in samples:
        delta = sample - prev
        # Clamp delta to 16-bit signed range
        delta = max(-32768, min(32767, delta))
        deltas.extend(struct.pack('<h', delta))  # little-endian signed 16-bit
        prev = sample
    return bytes(deltas)

def compress_waveform(samples):
    """Compress waveform using delta encoding + DEFLATE"""
    # Delta encode first
    delta_data = delta_encode(samples)

    # Compress with DEFLATE (zlib format)
    compressed = zlib.compress(delta_data, level=6)

    return compressed

def calculate_crc32(data):
    """Calculate CRC32 of raw 24-bit sample data"""
    return zlib.crc32(data) & 0xFFFFFFFF

def generate_c_array(data, name):
    """Generate C array declaration"""
    lines = [f"static const uint8_t {name}[] = {{"]

    for i in range(0, len(data), 16):
        chunk = data[i:i+16]
        hex_values = ', '.join(f'0x{b:02X}' for b in chunk)
        lines.append(f"    {hex_values},")

    lines.append("};")
    lines.append(f"#define {name.upper()}_SIZE {len(data)}")

    return '\n'.join(lines)

def main():
    print("Generating reference waveform...")
    samples = generate_waveform()

    print(f"Generated {len(samples)} samples")
    print(f"  Min: {min(samples)}, Max: {max(samples)}")

    # Pack to 24-bit format
    raw_data = pack_24bit_samples(samples)
    print(f"Raw data size: {len(raw_data)} bytes")

    # Calculate CRC32
    crc32 = calculate_crc32(raw_data)
    print(f"CRC32: 0x{crc32:08X}")

    # Compress
    compressed_data = compress_waveform(samples)
    print(f"Compressed size: {len(compressed_data)} bytes")
    print(f"Compression ratio: {100 * (1 - len(compressed_data) / len(raw_data)):.1f}%")

    # Generate C code for BOTH uncompressed and compressed data
    print("\nGenerating C header with static waveforms...")
    c_code = f"""/*
 * Static reference waveforms for benchmark testing
 * Generated by generate_compressed_waveform.py
 *
 * Contains both uncompressed and compressed waveform data
 * to eliminate runtime generation variability.
 *
 * Uncompressed size: {len(raw_data)} bytes (2376 samples Ã— 3 bytes)
 * Compressed size:   {len(compressed_data)} bytes
 * Compression ratio: {100 * (1 - len(compressed_data) / len(raw_data)):.1f}%
 * CRC32: 0x{crc32:08X}
 */

#ifndef STATIC_WAVEFORM_DATA_H_
#define STATIC_WAVEFORM_DATA_H_

#include <stdint.h>

/* Uncompressed waveform data (24-bit samples, little-endian) */
{generate_c_array(raw_data, 'uncompressed_waveform_data')}

/* Compressed waveform data (delta-encoded + DEFLATE) */
{generate_c_array(compressed_data, 'compressed_waveform_data')}

/* Metadata */
#define STATIC_WAVEFORM_CRC32 0x{crc32:08X}U
#define UNCOMPRESSED_WAVEFORM_DATA_SIZE {len(raw_data)}U
#define COMPRESSED_WAVEFORM_DATA_SIZE {len(compressed_data)}U

#endif /* STATIC_WAVEFORM_DATA_H_ */
"""

    with open('static_waveform_data.h', 'w') as f:
        f.write(c_code)

    print(f"Wrote static_waveform_data.h")
    print(f"\nStatic data ready:")
    print(f"  Uncompressed: {len(raw_data)} bytes")
    print(f"  Compressed:   {len(compressed_data)} bytes")
    print(f"  CRC32: 0x{crc32:08X}")

if __name__ == '__main__':
    main()
